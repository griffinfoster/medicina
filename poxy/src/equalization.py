#! /usr/bin/env python
"""
Class interface for tracking EQ coefficents
"""

import numpy as n
import time, struct, os
import cPickle as pickle

class EQ():
    def __init__(self, mode='amp', nchans=1024, nants=32, npols=1, decimation=1, flip_spectrum=True, dtype=float, fn=None):
        """
        init_coeff: a list or array of initial coefficents
        mode: string to describe the EQ format: 'amp','phs'
        fmt: init_coeff format
        nchans: number of FFT channels
        nants: number of ants
        npols: number of polarizations
        decimation: decimation factor of nchans to generate coeffs for
        flip_spectrum: Boolean value. True if spectrum is reversed (because of upstream mixing)
        dtype: data type of coefficients, eg, numpy.uint32, complex, etc
        """
        self.fn=fn
        self.nchans=nchans
        self.nants=nants
        self.npols=npols
        self.dec=decimation
        self.mode=mode
        self.flip_spectrum = flip_spectrum
        self.dtype = dtype
        self.ncoeffs = nchans/decimation

        # Now instantiate the actual coefficient objects
        # coeff_base are fundamental coefficients which are not related to calibration. E.g. constant pre-quantisation scaling values, or geometric beamforming phases
        self.coeff = {}
        self.coeff['base']=Coefficient(nchans=self.nchans, nants=self.nants, npols=self.npols, decimation=self.dec, flip_spectrum = self.flip_spectrum, dtype=self.dtype)
        # coeff_cal_bandpass are coefficients to calibrate for variations over the band. E.g. amplitude variation
        self.coeff['bandpass']=Coefficient(nchans=self.nchans, nants=self.nants, npols=self.npols, decimation=self.dec, flip_spectrum = self.flip_spectrum, dtype=self.dtype)
        # coeff_cal are other calibration coefficients. E.g. Beamforming complex gain calibrations
        self.coeff['cal']=Coefficient(nchans=self.nchans, nants=self.nants, npols=self.npols, decimation=self.dec, flip_spectrum = self.flip_spectrum, dtype=self.dtype)
        # coeff are used to track the actual values being loaded to the FPGA. These coefficients are generated by multiplying together any of the 3 coefficient sets.
        self.coeff['master']=Coefficient(nchans=self.nchans, nants=self.nants, npols=self.npols, decimation=self.dec, flip_spectrum = self.flip_spectrum, dtype=self.dtype)

    def read_pkl(self,fn=None):
        """Read a pickle file which contains a stored EQ dictionary"""
        if fn==None:
            fn=self.fn
        f = open(fn)
        try:
            eq_dict = pickle.load(f)
            f.close()
        except IOError:
            print '\n'
            print 'ERROR: Could not open coefficient pickle file %s' %fn
            print 'Perhaps it doesn\'t exist?, or you don\'t have the right permissions to read it'
            print 'Try running feng_init to regenerate this file'
            exit()

        self.nchans=eq_dict['nchans']
        self.npols=eq_dict['npols']
        self.nants=eq_dict['nants']
        self.dec=eq_dict['dec']
        self.mode=eq_dict['mode']
        self.coeff=eq_dict['coeff']
        self.dtype=eq_dict['dtype']
        self.flip_spectrum=eq_dict['flip_spectrum']
        self.fn=eq_dict['fn']
        self.ncoeffs=eq_dict['ncoeffs']
        self.shape = [self.nants,self.npols,self.nchans/self.dec]

    def write_pkl(self,fn=None):
        """Write a pickle file which contains an EQ dictionary"""
        if fn==None:
            fn=self.fn
        f = open(fn, 'wb')
        eq_dict = { 'nchans':self.nchans,
                    'npols':self.npols,
                    'nants':self.nants,
                    'dec':self.dec,
                    'mode':self.mode,
                    'coeff':self.coeff,
                    'dtype':self.dtype,
                    'flip_spectrum':self.flip_spectrum,
                    'fn':self.fn,
                    'ncoeffs':self.ncoeffs}
        pickle.dump(eq_dict, f)
        os.system('chmod 666 %s' %fn) #!!!
        f.close()

    def build_coeffs(self, use_base=True, use_bandpass=True, use_cal=True):
        if use_base: a = self.coeff['base'].coeff
        else: a = n.ones_like(self.coeff['base'].coeff)

        if use_bandpass: b = self.coeff['bandpass'].coeff
        else: b = n.ones_like(self.coeff['bandpass'].coeff)

        if use_cal: c = self.coeff['cal'].coeff
        else: c = n.ones_like(self.coeff['cal'].coeff)

        self.coeff['master'].coeff = a/b*c
    def get_coeffs(self, level='master'):
        return self.coeff[level].coeff

        


class Coefficient():
    def __init__(self, nchans=1024, nants=32, npols=1, decimation=1, flip_spectrum=False, dtype=float):
        self.nchans=nchans
        self.nants=nants
        self.npols=npols
        self.dec=decimation
        self.flip_spectrum = flip_spectrum
        self.dtype = dtype
        self.ncoeffs = nchans/decimation
        self.coeff = n.ones((self.nants,self.npols,self.nchans/self.dec),dtype=self.dtype)
        
    def flat_coeff(self,ant,pol,v):
        """set the coeffs for an antpol to a constant value"""
        self.coeff[ant,pol,:]=v*n.ones(self.nchans/self.dec)

    def apply_constant(self,ant,pol,v):
        """Multiply the current coeffs of an antpol by a constant value"""
        self.coeff[ant,pol,:]=v*self.coeff[ant,pol,:]

    def modify_coeffs(self, ant, pol, cal_coeffs, closed_loop=True, verbose=False):
        """Multiply the current coefficients by a constant, or a vector, or replace them with a new calibration set"""
        if n.size(cal_coeffs) == 1:
            cal_coeffs = n.array([cal_coeffs], dtype=self.dtype)

        if len(cal_coeffs) == len(self.coeff[ant,pol]):
            # Check the number of calibration coefficients is the same as the number of coefficients already associated with the manager instance
            dec_coeffs = n.array(cal_coeffs, dtype=self.dtype)
        elif len(cal_coeffs) == self.nchans:
            #if it isn't, but there are the same number of calibration coeffs as there are channels, then decimate and apply the calibration
            dec_coeffs = n.zeros_like(self.coeff[ant,pol])
            for i in range(self.ncoeffs):
                dec_coeffs[i] = n.average(cal_coeffs[i*self.dec:(i+1)*self.dec])
        elif len(cal_coeffs) == 1:
            #if there's only one calibration coefficient, apply it to all the channels
            dec_coeffs = n.ones_like(self.coeff[ant,pol])*cal_coeffs[0]
        else:
            raise IndexError('''The number of calibration coefficients don\'t seem to be the number
                             or frequency channels, the number of decimated channels or a single value. I have
                             no idea what to do!''')

        if closed_loop is False:
            self.coeff[ant][pol] = dec_coeffs
            if verbose:
                print 'ant %d, pol%d' %(ant,pol)
                print 'ABS'
                print n.abs(self.coeff[ant][pol])
                print 'PHASE'
                print n.angle(self.coeff[ant][pol])
        else:
            if verbose:
                print 'old coeff:', self.coeff[ant,pol]
                print 'calibration:', dec_coeffs
            self.coeff[ant,pol] = self.coeff[ant,pol] * dec_coeffs
            if verbose:
                print 'newcoeff:', self.coeff[ant,pol]
        return self.coeff

    def poly_coeff(self,ant,pol,v,start_chan=0,end_chan=-1):
        """set the coeffs for an antpol to the polyvals generated based on polynomial coeffs"""
        #Fit the entire band
        v = n.array([v],dtype=float).flatten()
        fit = n.polyval(v,range(self.nchans))
        fit_windowed = fit[start_chan:end_chan]
        #Find the mean over the useful part of the fit. Outside this part, use the mean as the coefficient
        spline = n.ones(self.nchans,dtype=self.dtype)
        spline[start_chan:end_chan] = fit_windowed
        spline[0:start_chan] = fit_windowed[0]
        spline[end_chan:] = fit_windowed[-1]
        if self.flip_spectrum:
            spline = spline[::-1]
        self.coeff[ant,pol,:]=spline[::self.dec]

    def flatten_band(self,band,ant,pol,mode='poly',deg=4,start_ch=0,end_ch=-1):
        """given a bandpass return the coeffs to produce a flat band, mode=poly will generate an n deg
        polynomial to fit the band between start_ch and end_ch,
        mode=coeff will return an inverse of the band such that all values are 1"""
        band=n.array(band)
        if mode=='coeff':
            band=n.clip(band,1,band.max())
            iband=1./band
            return iband
        elif mode=='poly':
            x=n.arange(len(band))
            sel_band=band[start_ch:end_ch]
            sel_x=x[start_ch:end_ch]
            pv=n.polyfit(sel_x,sel_band,deg)
            fitband=n.polyval(pv, x)
            fitband=n.clip(fitband,1,fitband.max())
            ifitband=1./fitband
            return fitband

    def gen_flat_coeffs(self,band,ant,pol,start_ch=0,end_ch=-1):
        """flatten the band and shift up the values to integer ranges"""
        flat_coeff=self.flatten_band(band,ant,pol,mode='poly',deg=4,start_ch=start_ch,end_ch=end_ch)
        flat_coeff=flat_coeff*(2**32)
        self.coeff[ant,pol,:]=flat_coeff[::self.dec]

    def get_coeffs(self):
        return self.coeff

    def set_coeffs(self, coeffs):
        if len(coeffs) != len(self.coeff):
            raise ValueError('Trying to set a coefficient array with the wrong number of coefficients')
        self.coeff = n.array(coeffs,self.dtype)

    def get_complex_fp(self, bitwidth, bp, signed=True):
        if signed:
            clipbits = bitwidth-1
        else:
            clipbits = bitwidth
        real = n.clip(n.round(n.real(self.coeff)*2**bp), -2**clipbits-1, 2**clipbits-1)
        imag = n.clip(n.round(n.imag(self.coeff)*2**bp), -2**clipbits-1, 2**clipbits-1)
        return n.array(real+1j*imag)

    def get_real_fp(self, bitwidth, bp, signed=False):
        if signed:
            clipbits = bitwidth-1
        else:
            clipbits = bitwidth
        return n.clip(n.round(n.real(self.coeff)*2**bp), -2**clipbits-1, 2**clipbits-1)

    def remove_dc(self):
        if self.flip_spectrum:
            self.coeff[-1] = 0
        else:
            self.coeff[0] = 0
